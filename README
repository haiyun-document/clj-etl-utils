# clj-etl-utils

ETL Utilities for Clojure.  This library was created as a collecitng point for
various utilities for handling a multitude of file encodings, record formats
and other ETL activities.

## Usage

Fill this in...

## Installation

Leiningen and Maven repository / depdencney inforamtion using Clojars.

## References

UTF and BOM
  http://unicode.org/faq/utf_bom.html

EncodingHeuristics
  http://downloads.atlassian.com/software/clover/samples/xom/nu/xom/xinclude/EncodingHeuristics.html
  http://xom.dev.java.net/source/browse/xom/

## License

This code is covered under the same as Clojure.


## HTTP Client

This is a wrapper around Apache Jakarta Commons HttpClent.  This is yet another http client library for clojure.  This implementation is not attempting to be dependency free (as are many of the other clojure http client libraries).  It is merely a convienience wrapper around the Jakarta Commons HttpClient.  I need to utilize many of the common features that user agents typically support such as: cookies, automatically following redirects, basic authentication including realms, automatic form encoding, posting non-form url encoded data, etc.  Jakart's HTTP Client fits this feature set very well, thought its api is not brief - this library attempts to make it more convienient to use without limiting access to any of its advanced features.


### User Agent

Creating a user agent is done by calling the @(user-agent) function.  It accepts two paramters: @:follow-redirects@ which controls whether or not it follows HTTP redirect responses to the pointed to locations; and @:basic-auth which allows you to supply authorization credentials for HTTP's basic auth system.

  (ws/get  (user-agent) url :params {:foo "bar"})
  (ws/post (user-agent) url :params {:foo "bar"})
  (ws/post (user-agent) url :body "this is the body" :content-type "text/plain")
  (ws/post (user-agent) url :body "<xml? ...>"       :content-type "text/xml")

  (defonce *ua* (user-agent :follow-redirects :true
                            ;; defaults to Realm/ANY, you can override with :realm value
                            :basic-auth {:user "bob" :pass "sekret"}))

  (let [req (ws/get-req url :params {:foo "bar"})]
    (ws/get *ua* req))

  (let [req (ws/get-req url :params {:foo "bar"})]
    (ws/get *ua* req))

  (ws/post *ua* url :params {:foo "bar"})
  (ws/post *ua* url :body "this is the body" :content-type "text/plain")


### Periodic Invoker

lang/make-periodic-invoker can be used to easily create 'progress' indicators or bars:

  (let [total    1000
        period     100
        progress (lang/make-periodic-invoker
                  period
                  (fn [val & [is-done]]
                    (if (= is-done :done)
                      (printf "All Done! %d\n" val)
                      (printf "So far we did %d, we are  %3.2f%% complete.\n" val (* 100.0 (/ val 1.0 total))))))]
    (dotimes [ii total]
      ;; do some work / processing here
      (progress))
    (progress :final :done))

Produces the following output:

  So far we did 100, we are  10.00% complete.
  So far we did 200, we are  20.00% complete.
  So far we did 300, we are  30.00% complete.
  So far we did 400, we are  40.00% complete.
  So far we did 500, we are  50.00% complete.
  So far we did 600, we are  60.00% complete.
  So far we did 700, we are  70.00% complete.
  So far we did 800, we are  80.00% complete.
  So far we did 900, we are  90.00% complete.
  So far we did 1000, we are  100.00% complete.
  All Done! 1000
